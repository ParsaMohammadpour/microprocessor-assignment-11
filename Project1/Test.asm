.MODEL SMALL
.STACK 64
.DATA
	STRING DB 'tryyourbestsebruoyyrt$' ; WE SHOULD PUT $ TO KNOW IF IT'S THE END OF THE STRING
	YES    DB 'YES$'
	NO	   DB 'NO$'
.CODE  

MAIN    PROC FAR
        MOV AX,@DATA
        MOV DS,AX
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; START
		MOV BX, OFFSET STRING ; LOAD THE ADDRESS OF THE START OF THE STRING
		;MOV DX, 0 ; DX WILL BE THE LENGTH OF THE STRING
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; FINDING LAST CHAR OF THE STRING ADDRESS
LENGTH_LOOP:
		MOV CL, [BX] ; CL IS A TEMP FOR GETTING THE VALUE STORED IN THE CURRENT INDEX OF STRING
		CMP CL, '$' ; CHECK IF WE ARE AT THE ENF OF THE STRING
		JE LENGTH_LOOP_END ; WE ARE AT THE END OF THE STRING (THE COMPARE RESULT SAYS THERE ARE THE SAME). SO THE LOOP IS FINISHED
		;ADD DX, 1 ; DX += 1 => ADDING NUMBER OF THE STRING LENGTH
		ADD BX, 1 ; BX += 1 => ADDING THE STARTING INDEX
		JMP LENGTH_LOOP ; BACK ON THE TOP OF THE LOOP
LENGTH_LOOP_END:


		
		


		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; FINDING IF THE STRING IS PALINDORM
		;;;;;;;;; BX = START INDEX     CX = END INDEX     DI = A TEMP FOR SAVING ADDRESS TO BE ABLE TO USE IN MOV INSTRUCTION
		;;;;;;;;; DL = THE CHAR WHICH IS LOCATED IN CX INDEX IN STRING
		MOV CX, BX ; BX IS THE ADDRESS OF THE LAST CHAR IN TSRING (CONTAINING $). SO CX IS NOW THE LAST CHAR ADDRESS
		SUB CX, 1  ; CX -= 1 => CX IS NOW THE ADDRESS OF THE LAST CHAR IN THE STRING (WITH OUT $)
		MOV BX, OFFSET STRING ; LOAD THE START INDEX OF THE START OF THE STRING
		;MOV BX, OFFSET STRING ; LOAD THE START INDEX OF THE START OF THE STRING
		;MOV CX, BX ; CX  = BX => CX IS NOW THE START ADDRESS OF THE STRING
		;ADD CX, DX ; CX += DX => CX IS NOW THE END OF THE STRING ADDRESS (BUT IT IS ADDRESS OF THE $)
		;SUB CX, 1  ; CX -= 1  => CX IS NOW THE END OF THE STRING ADDRESS (THE MAIN STRING WHICH DOES'T CONTAIN THE $)
PALINDORM_LOOP:
		CMP BX, CX ; COMARING THE INDEX OF THOESE CHAR WHICH ARE BEING COMPARED. IF THE INDEX WE STARTED FROM IS BIGGER, WE ARE DONE
		JGE PALINDORM_LOOP_END_EQUAL
		MOV DI, CX ; DI = CX => MOVING CX TO DI TO BE ABLE TO USING NEXT INSTRUCTION
		MOV DL, [DI] ; DL = STRING[DI] => DL IS TEMP, WHICH CONTAINS THE CHAR OF THE FIRST INDEX OF THE STRING
		CMP DL, [BX] ; COMPARING THE CHAR OF THE START INDEX OF THE STRING AND END INDEX OF THE STRING
		JNE PALINDORM_LOOP_END_NOT_EQUAL
		ADD BX, 1 ; BX += 1 => MOVE START INDEX ONE FRONT
		SUB CX, 1 ; CX -= 1 => MOVE END INDEX ONE POSITION BACK
		JMP PALINDORM_LOOP
		
PALINDORM_LOOP_END_EQUAL:
		MOV AH, 09H
		MOV DX, OFFSET YES
		INT 21H
		JMP PALINDORM_LOOP_END


PALINDORM_LOOP_END_NOT_EQUAL:
		MOV AH, 09H
		MOV DX, OFFSET NO
		INT 21H
		JMP PALINDORM_LOOP_END
		
		
PALINDORM_LOOP_END:



		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; FINDING NUMBER OF "Y" 'S IN STRING
		MOV BX, OFFSET STRING ; LOAD THE ADDRESS OF THE START OF THE STRING
		MOV DL, 0
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; GO THROUGH THE STRING
NUMBER_OF_Y:
		MOV CL, [BX] ; CL IS A TEMP FOR GETTING THE VALUE STORED IN THE CURRENT INDEX OF STRING
		CMP CL, '$' ; CHECK IF WE ARE AT THE ENF OF THE STRING
		JE NUMBER_OF_Y_END ; WE ARE AT THE END OF THE STRING (THE COMPARE RESULT SAYS THERE ARE THE SAME). SO THE LOOP IS FINISHED
		CMP CL, 'y'
		JE IF_BODY_START
		JNE END_IF
IF_BODY_START:
		ADD DL, 1 ; DL += 1 => INCREASE NUMBER OF "Y" 'S
END_IF:
		ADD BX, 1 ; BX += 1 => ADDING THE STARTING INDEX
		JMP NUMBER_OF_Y ; BACK ON THE TOP OF THE LOOP
NUMBER_OF_Y_END:




		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PRINTING "Y" 'S NUMBER IN STRING
		MOV AH, 02H
		ADD DL, "0"
		INT 21H
		
		
		MOV AH,4CH
        INT 21H
MAIN    ENDP

        END MAIN